package dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import db.DB;
import db.DbIntegrityException;
import model.Livro;

public class LivroDAO {

    /*
     * Inserção de livros (CREATE)
     */
    public static void inserir(Livro livro) {
        // SQL para inserir um novo livro na tabela 'livros'
        String sql = "INSERT INTO livros (titulo, autor, data_publicacao, quantidade_estoque) VALUES (?, ?, ?, ?)";
        
        // Utilizando try-with-resources para garantir o fechamento da conexão, PreparedStatement e ResultSet
        try (Connection conn = DB.getConnection();
             PreparedStatement st = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            // Exibe uma mensagem indicando o início da inserção
            System.out.println("==== INSERINDO NOVO LIVRO ====");

            // Define os valores que serão inseridos na consulta SQL
            st.setString(1, livro.getTitulo());
            st.setString(2, livro.getAutor());
            st.setDate(3, Date.valueOf(livro.getDataPublicacao()));  // Converte LocalDate para SQL Date
            st.setInt(4, livro.getQuantidadeEstoque());

            // Executa a inserção e verifica quantas linhas foram afetadas
            int rowsAffected = st.executeUpdate();

            if (rowsAffected > 0) {
                // Se o livro foi inserido, obtém o ID gerado
                try (ResultSet rs = st.getGeneratedKeys()) {
                    while (rs.next()) {
                        System.out.println("Livro inserido! Id = " + rs.getInt(1));  // Exibe o ID do livro inserido
                    }
                }
            } else {
                // Caso não tenha sido inserido nenhum livro, exibe uma mensagem
                System.out.println("Nenhum livro inserido!");
            }

        } catch (SQLException e) {
            e.printStackTrace();  // Em caso de erro, imprime o erro
        }
    }

    /*
     * Código para Recuperar Dados (READ)
     */
    public static List<Livro> listarLivros() {
        // SQL para selecionar todos os livros da tabela 'livros'
        String sql = "SELECT * FROM livros";
        List<Livro> lista = new ArrayList<>();  // Lista para armazenar os livros

        // Utilizando try-with-resources para garantir o fechamento da conexão, PreparedStatement e ResultSet
        try (Connection conn = DB.getConnection();
             PreparedStatement st = conn.prepareStatement(sql);
             ResultSet rs = st.executeQuery()) {

            // Exibe uma mensagem indicando que a listagem de livros começou
            System.out.println("==== LISTANDO LIVROS ====");

            // Itera sobre o ResultSet e cria um objeto Livro para cada registro
            while (rs.next()) {
                Livro livro = new Livro();
                livro.setId(rs.getInt("id_livro"));
                livro.setTitulo(rs.getString("titulo"));
                livro.setAutor(rs.getString("autor"));
                livro.setDataPublicacao(rs.getDate("data_publicacao").toLocalDate());  // Converte SQL Date para LocalDate
                livro.setQuantidadeEstoque(rs.getInt("quantidade_estoque"));

                lista.add(livro);  // Adiciona o livro à lista
            }

            // Exibe mensagem de término da listagem
            System.out.println("Listagem concluída.\n");

        } catch (SQLException e) {
            e.printStackTrace();  // Em caso de erro, imprime o erro
        }

        return lista;  // Retorna a lista de livros
    }

    /*
     * Atualizar dados (UPDATE)
     */
    public static void atualizarEstoque(int idLivro, int novaQuantidade) {
        // SQL para atualizar a quantidade de estoque de um livro
        String sql = "UPDATE livros SET quantidade_estoque = ? WHERE id_livro = ?";

        // Utilizando try-with-resources para garantir o fechamento da conexão e PreparedStatement
        try (Connection conn = DB.getConnection(); PreparedStatement st = conn.prepareStatement(sql)) {

            // Exibe uma mensagem indicando que o estoque do livro será atualizado
            System.out.println("==== ATUALIZANDO ESTOQUE DO LIVRO ====");

            // Define os parâmetros para a consulta SQL
            st.setInt(1, novaQuantidade);  // Novo valor de estoque
            st.setInt(2, idLivro);  // ID do livro a ser atualizado

            // Executa a atualização e verifica quantas linhas foram afetadas
            int rowsAffected = st.executeUpdate();

            if (rowsAffected > 0) {
                System.out.println("Livro com ID " + idLivro + " atualizado com sucesso.");
            } else {
                System.out.println("Nenhum livro atualizado, ID informado não existe!");
            }

        } catch (SQLException e) {
            e.printStackTrace();  // Em caso de erro, imprime o erro
        }
    }

    /*
     * Deletar dados (DELETE)
     */
    public static void deletarPorId(int idLivro) {
        // SQL para deletar um livro com base no ID
        String sql = "DELETE FROM livros WHERE id_livro = ?";

        // Utilizando try-with-resources para garantir o fechamento da conexão e PreparedStatement
        try (Connection conn = DB.getConnection(); PreparedStatement st = conn.prepareStatement(sql)) {

            // Exibe uma mensagem indicando que o livro será deletado
            System.out.println("==== DELETANDO LIVRO ====");

            // Define o parâmetro para a consulta SQL
            st.setInt(1, idLivro);  // ID do livro a ser deletado

            // Executa a deleção e verifica quantas linhas foram afetadas
            int rowsAffected = st.executeUpdate();

            if (rowsAffected > 0) {
                System.out.println("Livro com ID " + idLivro + " deletado com sucesso.");
            } else {
                System.out.println("Nenhum livro deletado. ID não encontrado.");
            }

        } catch (SQLException e) {
            // Lança uma exceção personalizada em caso de erro
            throw new DbIntegrityException("Erro ao tentar deletar o livro: " + e.getMessage());
        }
    }
}
